% 
% Submission to: http://wodes2014.lurpa.ens-cachan.fr/
% 
% \documentclass[a4paper,oneside]{article}
\documentclass[a4paper, 10pt, conference]{ieeeconf}
\IEEEoverridecommandlockouts
 % This command is only
  % needed if you want
  % to use the \thanks
  % command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\usepackage[pdftex, pdftitle={DiagnosabilityVerification of Discrete-Event
Systems}, pdfauthor={Dmitry Myadzelets}, bookmarks=false,
% colorlinks=true, linkcolor=black
]{hyperref}

\usepackage{amsfonts, amssymb, amsmath} 
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{arrows,positioning,automata,shadows,fit,shapes}
\usepackage{algpseudocode}

\usepackage{float}
\newfloat{algorithm}{t}{lop}
\floatname{algorithm}{Algorithm}

\begin{document}

\title{Virtual Modules in Discrete-Event Systems: 
Achieving Modular Diagnosability. General Form of the Approach}
\author{
	Dmitry Myadzelets$^{*,1,2}$
	, Andrea Paoli$^{1,3}$
	-- \today
	\thanks{$^{1}$Center for Research on Complex Automated Systems (CASY), DEI,
	University of Bologna, Viale Pepoli 3/2, 40123, Bologna, Italy}
		\thanks{$^{2}$E-mail: {dmitry.myadzelets@gmail.com}}
		\thanks{$^{3}$E-mail: {andrea.paoli@unibo.it}}
}
\maketitle

% To meet requirements of EU funding
% http://eacea.ec.europa.eu/about/eacea_logos_en.php "This project has been
% funded with support from the European Commission. This publication reflects
% the views only of the author, and the Commission cannot be held responsible
% for any use which may be made of the information contained therein."
\begin{figure}[!b]
\begin{tabular}{l p{60mm}}
 	\includegraphics[height=10mm]{EU_flag.eps}
 	& \vspace{-10mm} \footnotesize
 	$^{*}$With the support of the Erasmus Mundus Action 2 programme of the
 	European Union.
\end{tabular}
\end{figure}

\begin{abstract} In this paper, we investigate a problem of enforcing modular
diagnosability property of a system. We consider that a subset of the natural
modules may be viewed as one virtual module, and the system with such new
modularity becomes modular diagnosable. We introduce a formal definition of the
problem, and a structural analysis of a system that allows us to find which
modules can be considered as candidates for the virtual module. The analysis
doesn't require construction of the global system's model. Algorithms and an
example are presented.
\end{abstract}

\begin{keywords}
Discrete Event Systems, Modular Structure, Distributed Diagnosability
\end{keywords}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}
% \newtheorem{algorithm}{Algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In Discrete-Event Systems, diagnosis of a fault is a problem of deciding whether
or not the fault occurred, under partial observation of the system's events.
The problem was defined in \cite{sampath_diagnosability_1995} where the authors
consider a monolithic model of the system. This definition and new definitions
of diagnosability problem, emerged later, may be grouped as, for example, in
\cite{su_global_2005}, where an approach can be centralized as in
\cite{sampath_diagnosability_1995}, \cite{jiang_polynomial_2001} and
\cite{yoo_polynomial-time_2002}, 
decentralized as in \cite{debouk_coordinated_1998},
\cite{pencole_formal_2005} and \cite{qiu_decentralized_2006}, 
or distributed as in \cite{su_distributed_2002}.
The centralized and decentralized approaches require building of a monolithic
model. This process corresponds with exponential growth of the model's state
space, which makes the diagnosability problem intractable for complex large
systems with high modularity.

Distributed approach does not require to built the entire model of
the system. It implies that the system has a set of observation spots
(diagnosers), each observing only a part of the system (composed of a subset of
modules). Diagnosers can communicate to each other in order to decide if a fault
occurred. In general, the bigger the observation spots for the same
system, the less communications among the spots is required.
Figure \ref{fig:curves} shows that the average size of a module grows while the
system's modules are composed together (we imply that each module is represented
by automata, and the size of a module is reflected by the number of states of
the correspondent automaton).
A shape of this curve depends mostly on the order the modules are taken for the
composition, but the initial point, when the system has maximal modularity, and
the final point, when all the modules are composed into one monolithic module,
remain the same. Assuming that the system is diagnosable, the average size of a
diagnoser grows much faster, since it is exponential with respect to the average
size of a module, in the worst case.
The amount of events the diagnosers have to exchange among each other, in order
to decide if a fault occurred, is decreasing. The reason the diagnosers require
less event for decision making is due to the fact that they become more
self-sufficient, since amount of observable events available for each
diagnoser without communications is growing. Thus, the events exchange rate
decreases down to the point where no communications is required to make a
decision about the faults occurrence. That is the point when the system becomes
modular diagnosable (notion of modular diagnosability was introduced in
\cite{contant_diagnosability_2006}). The following composition of the modules
does not affect diagnosability, and leads only to the growth of the modules' and
diagnosers' sizes. 

In our approach, given a system with an initial natural modularity, we search
for a point, when the system is modular diagnosable. If the system is diagnosable,
then this point can always be found. The modules correspondent to that
modularity we call \emph{virtual}, since they are not composed in reality, and
used only to build diagnosers.

\begin{figure}
\begin{tikzpicture}
% \draw[help lines] (0,0) grid (5,3);
% Axis 
\draw [thick, <->] 
	(0,3) node[left]{Events} -- 
	(0,0) node[below]{0} -- 
	(6,0) node[below]{1} -- 
	(6,3) node[right]{States};
\node [below] at (3,0) {1/Number of modules};
% Curve of the average size of modules
\draw[blue, thick] (0.1,.1) to [out=0,in=-170] (6,2.5); 
% Curve of the average size of diagnosers
\draw[red, thick, dashed] (0.1,.3) to [out=0,in=-140] (4,3); 
% Curve of the amount of communication
\draw[orange, thick, dotted] (0.1,2.5) to [out=-15,in=160] (3.5,0); 
% Line of the point with virtual modularity
\draw[dashed] (3.5,0) -- (3.5,3);
% Point of virtual modularity  
\draw [fill] (3.5,0) circle [radius=0.05];
\draw [fill, blue] (3.5,1.42) circle[radius=0.05] 
	node[align=left, black, below right] {Virtual\\ modules}; 
\draw [fill, red] (3.5,2.55) circle [radius=0.05];
% Legend
\draw[blue, thick] (0,-1) -- (1,-1)
	node[black, right] {Average size of module, states};
\draw[red, thick, dashed] (0,-1.4) -- (1,-1.4)
	node[black, right] {Average size of diagnoser, states};
\draw[orange, thick, dotted] (0,-1.8) -- (1,-1.8) 
	node[black, right] {Events exchange rate};

\end{tikzpicture}
\caption{Changing of size of modules, diagnosers, and events exchange rate
with respect to the number of modules in the same system}
\label{fig:curves}
\end{figure}

In our previous paper \cite{myadzelets_virtual_2013} we introduced a notion of
diagnosability by virtual modules, and studied a system consisting of
two modules. For such simple system we defined sufficient and necessary
conditions for the modules' languages, such that if the modules satisfy that
conditions, than the system is modular diagnosable by the virtual module
composed of those modules. In this paper we present a general form of our
approach, and algorithms which allow to find candidates for virtual modules
without building the monolithic system's model. Also we define criteria how to
choose the best candidates for a virtual module if many of them are found.

The rest of the paper is organized as follows. We first give a necessary
notation in Section \ref{sec:Preliminaries}. Then, in Section \ref{sec:General}
we present the general form of the approach. Section \ref{sec:algorithms}
describes algorithms to find candidates for virtual modules, and to choose the
best candidates. Example with a simple system of four modules is presented in
Section \ref{sec:Example}, and Section \ref{sec:Conclusions} concludes this
paper.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}
\label{sec:Preliminaries}

% \subsection{Notation}
The notation used in this document is the one in
\cite{cassandras_introduction_2010}.
Let $\Sigma$ be a finite set of events. A sequence of events is a string.
$\Sigma^*$ denotes a set of all finite strings over $\Sigma$.
$L\subseteq\Sigma^*$ is a language over $\Sigma$. Given strings $s$ and $t$,
$st$ is their concatenation. Given strings $s$ and $w$, $w$ is a prefix of $s$
if exists $t$ such that $wt = s$. Prefix closure of $L$, denoted by
$\overline{L}$ is a set of all prefixes of all the strings in $L$.
If $\overline{L} = L$ then $L$ is prefix-closed. The post language of $L$ after
a string $s$ is denoted as $L/s$, i.e. $L/s := \{t\mid st \in L\}$. We
write $\sigma \in s$ if the event $\sigma \in \Sigma$ appears in the string $s
\in \Sigma^*$. If $\{s\}$ is a singleton, we write $s$ for operations on
languages.

An automaton $G$ is a tuple $$G := \left< X,\Sigma,\delta,x_0, X_m \right>,$$
where $X$ is a set of states, $x_0 \in X$ is an initial state, $X_m \subseteq X$
is the set of marked states, and $\delta: X \times \Sigma \rightarrow X$ is the
transition function.
We say a language $L := \mathcal{L}(G)$ is generated or recognized by the
automaton $G$. In this paper we assume that for each language there is always a
correspondent automaton, and vice versa. The marked language $L_m \subseteq L$
is intended to make a part of the automaton's behaviour distinguishable in a
certain context.

Some events of DES can not be observed. To reflect that the set of events
$\Sigma$ is partitioned into disjointed sets of observable events $\Sigma_o$ and
not observable events $\Sigma_{ou}$, i.e. $\Sigma = \Sigma_o~\dot{\cup}~
\Sigma_{ou}$.
The $M: \Sigma^* \rightarrow \Sigma_o^*$ denotes the natural projection that
erases unobservable events.
% ; $\epsilon$ means the empty string. 
The correspondent inverse projection is $M^{-1}: \Sigma_o^* \rightarrow
2^{\Sigma^*}$.
If a set of events is partitioned into subsets, $\Sigma := \bigcup_i
\Sigma_{i} \mid i \in \mathbb{N}$, the natural projection over the partition
members is denoted as $M_i: \Sigma_i^* \rightarrow \Sigma_{i,o}^*$.

Let $I := \{1,2,\ldots,n\} \subset  \mathbb{N}$ be an index set. A system is
defined by a set of automata $\{G_{i \in I}\}$ and a correspondent set of
languages $\{L_{i \in I}\}$. We use the term \emph{local} in context of the
automata and languages from these sets. The \emph{global} language of the system
is defined by the parallel composition \cite{cassandras_introduction_2010} of
its local languages:
$L := \parallel_{i \in I} L_i$.
The natural projection is commonly defined over Kleene closure on event sets.
We restrict it, for simplicity of notation, to the system's languages as
follows: $P_i(L) := \{s\mid s\in L_{i}\}$, and 
$P_i^{-1}(L_{i}) := \{s \mid s \in L, P_i(s) \in L_i\}, ~i \in I$.


% \subsection{Adjacency graph}
% A DES can be seen as a graph where its nodes represent the modules, and edges
% reflect the fact that some modules are synchronized with each other. This
% abstraction is often implicitly or explicitly used in approaches devoted to
% diagnosability of modular systems. In our approach we denote such graph as the
% \emph{adjacency graph}, formally defined as follows:
% \begin{definition}
% \label{def:graph_events}
% Given $\{\Sigma_i \mid i \in I \}$, let $\mathcal{G} = \left<I, E\right>$ be an
% undirected adjacency graph where $E \subseteq I \times
% I$ such that 
% $$(\forall i, j \in I)(i, j) \in E \Leftrightarrow 
% 	\Sigma_i \cap \Sigma_j \neq \emptyset \mid i \neq j.$$
% \end{definition}
% We extend this definition over languages.
% \begin{definition}
% \label{def:graph_languages}
% The adjacency graph over a set of languages $\{L_i \subseteq \Sigma_i^* \mid i
% \in I \}$ is a graph $\mathcal{G} = \left<I, E\right>$ where $E \subseteq I \times
% I$ such that 
% $$(\forall i, j \in I)(i, j) \in E \Leftrightarrow
% 	P_{i,j}^{-1}(L_i) \cap P_{i,j}^{-1}(L_j) \neq \emptyset \mid i \neq j, 
% $$
% where 
% $P_{i,j} : (\Sigma_i \cup \Sigma_j)^* \rightarrow (\Sigma_i \cap \Sigma_j)^*$
% , and  
% $P_{i,j}^{-1}(s) := \{t \in (\Sigma_i \cup \Sigma_j)^* \mid P_{i,j}(t) = s\}$.
% \end{definition}
% 
% By definition, the adjacency graph over $\{\Sigma_i\}$ is a supergraph for any
% graph over $\{L_i \subseteq \Sigma_i\}$, and any adjacency graph over $\{L'_i
% \subseteq L_i\}$ is a subgraph of the adjacency graph over $\{L_i\}$.
% 
% % Recall that in graph theory a simple path is a path in a graph which does not
% % have repeating vertices.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{General form of the approach}
\label{sec:General}

% [Formal problem definition]
% [Figure of modular and decentralized diagnosability (from the presentation)]

% In our previous paper \cite{myadzelets_virtual_2013} we considered a trivial
% system of two modules, where one module has fault, not diagnosable locally.
% We found conditions for the both languages, such that if the languages satisfy
% them, then the system is diagnosable. The correspondent properties of the
% languages can be verified locally, with no construction of the global language.
% 
% In this case one can compose all the other languages with the faulty language,
% reducing the system to the form of the trivial case. A formal description of
% such approach is given below.

The setup for the problem is following. Let a system be defined as a set of
local languages $S := \{L_{i\in I}\}$, and let faulty behaviour be defined for
any $i \in I$, i.e. each language $L_i$ can be disjoint into faulty and
non-faulty sublanguages: $L_{i,f}$ and $L_{i,nf}$. For the sake of simplicity,
we assume that a language may have only one type of fault. We assume that
$(\forall i \in I)\left[ L_i = P_i(L)\right]$. The motivation for this
assumption is following. Most of real-life complex systems are of high
modularity, where each module is presented as a small model along with
correspondent faults as, for example, in \cite{sartini_methodology_2010}. When
properly designed, such systems have neither deadlocks no trajectories in models
which never executed. Such assumption also may require construction of a
supervisor, and verification that a local language of each module is globally
consistent, before checking diagnosability of the system.

First, we recall definition of diagnosability of virtual modules, introduced in
\cite{myadzelets_virtual_2013}.
Let $J$ be a partition of $I$. Given a set of system's languages $\{L_{i \in
I}\}$ and a set of observable projections $\{M_j := \Sigma_j^* \rightarrow
\Sigma_{j,o}^* \mid j \in J \}$
where $\Sigma_j := \bigcup_i \Sigma_i,~ 
	\Sigma_{j,o} := \bigcup_i \Sigma_{i,o} \mid 
	i\in j$. 
The system is modularly diagnosable with respect to $J$ and $\{M_j\}$ 
if the following holds:
\begin{equation}
	\begin{array}{l}
		\forall(i \in I, s \in L_{i,f}, t \in L_{i,f}/s)
		\\
		(\exists n \in \mathbb{N})
		(|t| \geq n)
		\\
		\left[ M_j(P_i^{-1}(st)) \cap M_j(P_i^{-1}(L_{i,nf})) = \emptyset \right].
	\end{array}
\end{equation}
The definition requires each fault originated in any language of the subset $j$
to be diagnosed by observing only events of the languages from the same subset
$j$.
% However, the languages $L_j$ are not given, and they do not have to be necessary
% constructed. That is why we use the term \emph{virtual module} as a synonym for
% the subset $j$.

Second, we recall Lemma 2 \cite{myadzelets_virtual_2013}, where the statements
hold for a system of two languages, and rewrite it for an arbitrary couple
of languages for any system, as follows.

\begin{lemma}
\label{lem:distinguished}
Given a tuple $\left< L_i, L_j, s, u\right> \mid i, j \in \mathbb{N}, i\neq j$
and $s, u \in L_i$. The strings $s, u$ are
distinguished in the language $L_i \parallel L_j$ if for the string $s$ exists
an adjacent observable support $K_j \subseteq L_j$ which satisfies the
condition:
\end{lemma} 
\begin{equation}
\label{con:distinquished}
	\begin{array}{l}
	 	(\forall t \in K_j)
	 	(\exists \sigma \in t \mid \sigma \in \Sigma_i \cap \Sigma_j)
	 	(\sigma \not \in u)
	 	\\
	 	(\forall w\sigma \in \overline{t})
	 	[M_j(t / w\sigma) \neq \emptyset].
	\end{array}
\end{equation}
% where $M'_j: (\Sigma_i \cup \Sigma_j)^* \rightarrow (\Sigma_{j,o}\backslash
% \Sigma_i)^*$.
Informally, the lemma imposes a requirement for the string $s$ to have an
observable support (subset of observable strings ending with common events) in
another language, which guaranties that we can observe some events in that
language before any continuation of the string $s$.
Then, the lemma defines a condition which allows us to distinguish these
observations from the observation of the string $u$.

Now, we rewrite Lemma 3 \cite{myadzelets_virtual_2013}, in the context of our
setup, as follows:
\begin{lemma}
\label{lem:virtual_module_is_diagnosable}
Given a virtual module $j \in J$, the module is diagnosable with respect to
$M_j$ if:
\end{lemma}
\begin{equation}
	\begin{array}{l}
% 		(\forall i \in j, s \in L_{i,f}, t \in L_i \backslash \overline{L_{i,f}})
		(\forall i \in j, 
			s \in P_i^{-1}(L_{i,f}), 
			t \in P_i^{-1}(L_{i,nf}))
% 			t \in P_i^{-1}(L_i) \backslash \overline{P_i^{-1}(L_{i,f})})
		\\
		(\exists k \in j \mid k \neq i) \textrm{ and }
		\\
		\textrm{condition (\ref{con:distinquished}) holds for at least one of
		the tuples:}
		\\
		\left<P_i^{-1}(L_i), L_k, s, t \right>,
		\left<P_i^{-1}(L_i), L_k, t, s \right>.
	\end{array}
\end{equation}
The lemma implies, that the virtual module is diagnosable if we can distinguish
all faulty strings from all non-faulty strings. 
% excluding all prefixies of the faulty strings
% Note, that exclusion of the prefixes comes from fact that the non-compositional
% analysis is used.
From the lemma it can be seen that for one faulty sublanguage there can be a
subset of languages with observable supports, satisfying the conditions. In
order to make the system modularly diagnosable, thus, one needs to find a
relevant partition, with a desired distribution of modules over the partition.
It worth to note, that the partitioning implies that languages with faults are
in subsets with the languages which have observable events. Thus, other
languages which have no faults and have no observable events, as well the
languages with observations which have no effect for the diagnosability
property, will be in other subsets.

One faulty module also may require a few modules with observable supports.
The algorithms presented in the following section are aimed to find such subset
of system's modules. The first algorithm may be viewed as a \emph{forward
propagation} procedure. It starts from the faulty module, and propagates faulty
and non-faulty information trough all the modules, according to some
of requirements of the lemmas \ref{lem:distinguished} and
\ref{lem:virtual_module_is_diagnosable} related to common events. The second
algorithm may be viewed as a \emph{backward propagation} procedure. It starts
from a module with observable support, and propagates information related to
observable events toward the faulty module, according to the rest of the lemmas'
requirements.


\section{Algorithms for diagnosability by virtual modules}
\label{sec:algorithms}

Assume that given a language with a faulty behaviour and a language which has an
observable support. It is required to verify if the observable support is
either for the faulty or non-faulty sublanguages. If it is true, then the
correspondent modules can be composed into a virtual module.
According to the Lemma \ref{lem:virtual_module_is_diagnosable}, in order to
decide if the virtual module is diagnosable we need to verify the necessary
conditions for all the strings $P_i^{-1}(L_{i,f})$ and $P_i^{-1}(L_{i,nf})$,
projected to the local languages of other modules. Those local projections are
the basic elements our algorithms operate with. In the sequel we
refer to the correspondent local sublanguages as to \emph{co-faulty} and
\emph{co-non-faulty} ones. A formal definition of these sublanguages is
presented below, and then an algorithm which computes the co-faulty
and co-non-faulty sublanguages for all the system's modules, is given. It is
followed by algorithms which verify diagnosability and find a virtual module.

\subsection{Co-faulty and co-non-faulty sublanguages}

\begin{definition}
\label{def:co-faulty}
Given $i, j \in I$, $L_{i,f} \subseteq L_i$,
we say that a sublanguage $L_{j,cf} \subseteq L_j$ is \emph{co-faulty} with
respect to $L_{i,f}$ if 
$$
	(\forall s \in L_{j,cf})(\forall t \in P_i[P_j^{-1}(s)])
	\left[
		t \in L_{i,f} \land t \not \in L_{i,nf}   
	\right],
$$ 
and a sublanguage $L_{j,cnf} \subseteq L_j$ is
\emph{co-non-faulty} with respect to $L_{i,nf}$ if 
$$
	(\forall s \in L_{j,cnf})(\forall t \in P_i[P_j^{-1}(s)])
	\left[
		t \not \in L_{i,f} \land t \in L_{i,nf}   
	\right].
$$ 
\end{definition}

In words, the co-faulty sublanguage is a sublanguage which satisfies two
conditions:
a) it is the sublanguage of projection of the global faulty language
to the local language; b) the sublanguage is not co-non-faulty.
Similarly, the co-non-faulty sublanguage is a sublanguage which satisfies
conditions:
a) it is the sublanguage of projection of the global non-faulty language
to the local language; b) the sublanguage is not co-faulty.

% \begin{lemma}
% \label{lem:empty_co_if_no_common}  
% Given a language $L_j\mid j \in I$, its co-faulty and
% co-non-faulty sublanguages are empty, if the language has no common events in
% its strings, i.e
% $$P_{\Sigma_j \rightarrow \bigcap_{i\neq j}^I \Sigma_i}(L_i) = \emptyset.$$
% \end{lemma}

We skip the proof due to its triviality. 

Given global faulty and non-faulty sublanguages, one can compute the local
co-faulty sublanguage as follows:
\begin{equation}
\label{eq:co-faulty_from_global}
	\begin{array}{l}
		L_{j,cf} := P_j(L_f) \backslash P_j(L_{nf}),\\ 
		L_{j,cnf} := P_j(L_{nf}) \backslash P_j(L_{f}).	
	\end{array}
\end{equation}
However, we are interested to compute a local co-faulty
language without computing the global language. Since the global
faulty sublanguage is define as
\begin{equation}
\label{eq:co-faulty_from_locals}
	L_f := P_i^{-1}(L_{i,f}) \cap \bigcap_{k\neq
	i}^I P_k^{-1}(L_k),
\end{equation}
then, by substituting the global language in \ref{eq:co-faulty_from_global} by
\ref{eq:co-faulty_from_locals}, and by mathematical induction, the co-faulty
sublanguage of an arbitrary module can be computed as follows:
% \begin{equation}
% 	\begin{array}{ll}
% 		L_{j,cf} := 
% 		&
% 		\bigcap_k^I P_j[P_k^{-1}(L_{k,cf}) \cap P_i^{-1}(L_{i,f})] 
% 		\backslash \\
% 		&
% 		\bigcap_k^I P_j[P_k^{-1}(L_{k,cnf}) \cap P_i^{-1}(L_{i,nf})],
% 		\\ & \textrm{where } i\neq j\neq k \in I.
% 	\end{array}
% \end{equation}
\begin{equation}
\label{eq:co-faulty_iterative_w_faulty}
	\begin{array}{l}
		L_{j,cf} := 
		\\
		P_j\Big(P_j^{-1}(L_j) \cap P_i^{-1}(L_{i,f})\cap 
		\bigcap_k^I P_k^{-1}(L_{k,cf})\Big) \backslash 
		\\
		P_j\Big(P_j^{-1}(L_j) \cap P_i^{-1}(L_{i,nf})\cap 
		\bigcap_k^I P_k^{-1}(L_{k,cnf})\Big),
		\\ 
		\textrm{where } i\neq j\neq k \in I.
	\end{array}
\end{equation}

We skip the definition of co-non-faulty sublanguage here due to its similarity. 

% According to Definition \ref{def:co-faulty}, any faulty language is co-faulty to
% itself. It allows us to simplify the above equation, and rewrite it as follows:
% 
% \begin{equation}
% \label{}
% 	\begin{array}{l}
% 		L_{j,cf} := 
% 		\\
% 		P_j\Big(P_j^{-1}(L_j) \cap 
% 		\bigcap_i^I P_i^{-1}(L_{i,cf})\Big) \backslash 
% 		\\
% 		P_j\Big(P_j^{-1}(L_j) \cap 
% 		\bigcap_i^I P_i^{-1}(L_{i,cnf})\Big),
% 		\\ 
% 		\textrm{where } i\neq j\in I.
% 	\end{array}
% \end{equation}

% In the following, when we assume that statements for co-faulty sublanguages also
% valid for co-non-faulty sublanguages.


% By definition, any faulty sublanguage is co-faulty with respect to itself.
% We use this property to establish relations  
% is used in the following lemma which establishes relation
% of co-faulty languages.
% 
% 
% 
% \begin{lemma}
% \label{lem:co-faulty-if-path}
% Given a set of languages $\{L_i \subseteq \Sigma_i^* \mid i \in I \}$ and the 
% adjacency graph $\mathcal{G}$ over this set. Any two vertexes $i, j \in I$,
% connected in the graph $\mathcal{G}$, also connected in the subgraph
% $\mathcal{G}_f$ over the set of co-faulty sublanguages $\{L_{i,cf}\}$, only if
% $$
% .
% $$
% Given $L_{i,f} \mid i \in I$ and set $\{L_{j,cf} \subseteq L_j \mid j \in J
% \subseteq I, j \neq i\}$ where $L_{j,cf}$ is co-faulty with respect to $L_{i,f}$. 
% For any $j \in J$ the $L_{j,cf}$ is not empty only if exists a path between $i$
% and $j$ in the adjacency graph $\mathcal{G}$ over languages.
% \end{lemma}

% \begin{proof} 
% Trivially, by induction from the definition of parallel composition of automata
% as a natural representation of parallel composition for languages.
% % (Sketch) 
% % Let $I = \{i, j\}$ and a faulty non empty sublanguage
% % $L_{i,f} \subseteq L_i$. Assume that $L_{j,cf} \subseteq L_j$ is not
% % empty, and there is no path between $i$ and $j$ in the graph, i.e.
% % $\Sigma_i \cap \Sigma_j = \emptyset$. \ldots by properties of intersection of
% % inverse projections (parallel composition).
% \end{proof}

% \begin{algorithm} Computing the co-faulty and co-non-faulty languages of an
% adjacent module.
% \label{alg:partial_co_faulty}
% \begin{algorithmic}[1]
% 	\Require $L_i, L_{i,cf}, L_{i,cnf}, L_j$
% 	\State $\Sigma_c \leftarrow \Sigma_i \cap \Sigma_j$ 
% 		\label{alg:pcf_get_common}
% 	\State $F \leftarrow P_{\Sigma_i \rightarrow \Sigma_c}(L_{i,cf})$
% 		\label{alg:pcf_get_common_f}
% 	\State $N \leftarrow P_{\Sigma_i \rightarrow \Sigma_c}(L_{i,cnf})$
% 		\label{alg:pcf_get_common_n}
% 	\State $K \leftarrow F \cap N$
% 		\label{alg:pcf_get_fn}
% 	\State $F \leftarrow F\backslash K$
% 		\label{alg:pcf_get_f}
% 	\State $N \leftarrow N\backslash K$
% 		\label{alg:pcf_get_n}
% 	\State $L_{j,cf} \leftarrow 
% 		L_j \cap P_{\Sigma_j \rightarrow \Sigma_c}^{-1}(F)$
% 		\label{alg:pcf_get_cf}
% 	\State $L_{j,cnf} \leftarrow 
% 		L_j \cap P_{\Sigma_j \rightarrow \Sigma_c}^{-1}(N)$
% 		\label{alg:pcf_get_cnf}
% 	\\
% 	\Return $L_{j,cf}, L_{j,cnf}$
% \end{algorithmic}
% \end{algorithm}
% 
% At the steps \ref{alg:pcf_get_common_f} and \ref{alg:pcf_get_common_n} of the
% above algorithm we compute projections of known faulty and non-faulty languages.
% Note, that natural projection operation preserves faulty property of languages,
% as well as construction of correspondent deterministic automata. The both
% languages $L_{i,cf}$ and $L_{i,cnf}$ are not prefix-closed, in general. Then,
% their projections $F$ and $N$, with respect to the common events, may be not
% prefix-closed either. At the step \ref{alg:pcf_get_fn} the prefix common to the
% $F$ and $N$ is computed. Then, at the steps \ref{alg:pcf_get_f} and
% \ref{alg:pcf_get_n} we update languages subtracting their common prefix.
% Finally, we compute co-faulty and co-non-faulty languages for the adjacent
% module. In this sequence of operations at the steps
% \ref{alg:pcf_get_common_f}--\ref{alg:pcf_get_cnf} new automata for the
% correspondent languages are constructed or modified, and all the operations can
% be performed using standard software libraries.
% 
% Note, that the the Algorithm \ref{alg:partial_co_faulty} returns the co-faulty
% sublanguage of the module $j$, and this sublanguage is co-faulty with
% respect to only the module $i$, i.e. it is computed only partially. According to
% (\ref{eq:co-faulty_iterative_w_faulty}), in order to compute the full co-faulty
% sublanguage, we need to iterate over all the co-faulty sublanguages, as
% presented in the following algorithm. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Review of existing approaches}
% 
% The work \cite{su_global_2005} presents an algorithm named \emph{Computational
% Procedure for Global Consistency (CPGS)} to find the \emph{supremal
% global support}. Given a system 
% $\{ L_i \mid i \in I \subset \mathbb{N} \}$ 
% and its projections $\{ M_i \}$, the supremal global support is
% \begin{equation}
% 	Sup\Gamma = \{ P_i(\parallel M_i^{-1}M_i(L_i))\}.
% \end{equation}
% Informally, a string of a local language is in the global support if the string
% satisfies the conditions:
% \begin{enumerate}
%   \item the string contains observable events;
%   \item the string is not blocked in the global language. 
% \end{enumerate}
% Supremum implies that all the strings satisfying the above conditions have
% been found.
% 
% In words, the CPGS algorithm consequently computes the projection to the common
% events and then the parallel composition of this projection with a next module.
% Thus, the last language in the sequence is equal to $P_i(L)$. The above
% procedure is repeated with each module placed as the final in the sequence.
% 
% The order the modules are placed in the sequence for the algorithm may be
% random. Since here only common events cause growth of the composed language,
% intuitively, the ordering should be done with respect to them. Indeed, the
% article presents a heuristic ordering procedure for that, and introduces some
% parameters described below.
% 
% The first parameter represents the space complexity of parallel composition of
% two languages as follows:
% \begin{equation}
% 	A_{i,j} = \frac{| X_i \parallel X_j |}{|X_i|\times |X_j|}.
% \end{equation}
% It is the ratio of the minimal state space cardinality of the actual parallel
% composition result to the state space cardinality of the composition in the
% worst case.
% 
% The second parameter represents the space complexity of natural projection with
% respect to the events common for two languages:
% \begin{equation}
% 	B_{i,j} = \frac{
% 		| P_{\Sigma_i \cup \Sigma_j \rightarrow \Sigma_i \cap \Sigma_j}
% 		(X_i \parallel X_j) |}
% 		{| X_i \parallel X_j |}.
% \end{equation}
% It is the ratio of the minimal state space cardinality of the projection to the
% state space cardinality of the original language.
% 
% The lower the parameter $A$ the higher the coupling of two modules, i.e. more
% common events the modules have, and less memory is required for the computation
% of the parallel composition. Hence, we are interested to minimize $A$. The lower
% parameter $B$ implies less memory for the result of the projection. However,
% trying to minimize $B$ can lead to the increasing of $A$. Thus, the authors
% minimize both $A$ and $B$. Since at each step of the algorithm only one module is
% selected, the parameters can not be minimized independently. Therefore, the
% product of $A$ and $B$ was chosen to be minimized:
% \begin{equation}
% 	C = A \times B = 
% 		\frac{| P_{\Sigma_i \cup \Sigma_j \rightarrow \Sigma_i \cap \Sigma_j}
% 		(X_i \parallel X_j) |}
% 		{|X_i|\times |X_j|}.
% \end{equation}
% 
% In computer science the algorithm the authors use is called \emph{greedy
% algorithm}. Here it starts with a random module, and makes a local optimal
% choice based on the value of parameters $C$ calculated for the candidate set.
% The candidate set includes all the neighbor modules except the goal module. If
% the set of neighbors is empty then it includes all unprocessed modules except
% the goal module. The algorithm finishes after no any but the goal module can be
% included to the candidate set.
% 
% The time complexity of the algorithm is $O(n^2)$. It requires $|X|^n$ state
% space in the worst case, when a goal module splits the coupling graph into
% separate parts (star shape). 
% % However, the space complexity can be impoved up to $n|X|$ if the splitted parts
% % are processed separately first, and then the goal module is processed with all
% % of them. << Too BIG complexity difference. Check it twice!

\begin{algorithm}
\caption{Computing all co-faulty and co-non-faulty languages of
all the modules}
\begin{algorithmic}[1]
	\Require The set of the system's languages $\{L_j\mid j \in I\}$, faulty and
	non-faulty sublanguages $L_{i,f}$, $L_{i,nf}$ of a faulty module $i\in I$.
	\ForAll{$j \in I$}
	\label{alg:fcf_init}
		\Comment{Initialization}
		\State $C_j \leftarrow 
			P_{\Sigma_j \rightarrow \bigcup_{i\neq j}^I \Sigma_i\cap \Sigma_j}(L_j)$
		\State $F_j \leftarrow \emptyset, N_j \leftarrow \emptyset$
		\State $\Sigma_{j,c} \leftarrow \{\sigma \in s \mid s \in C_j\}$
	\EndFor
	\Procedure{propagate-fn}{$k$, $F_k$, $N_k$}
		\ForAll{$j \in I \mid j\neq i, j \textrm{ is adjacent to } k,
				\Sigma_{j,c}\neq \emptyset$} 
			\State $F'_j \leftarrow (
			P_{\Sigma_j \rightarrow \Sigma_j \cap \Sigma_k}^{-1}(F_k)
			\cap 
			P_{\Sigma_j \rightarrow \Sigma_j \cap \Sigma_k}^{-1}(C_j) 
			)\cap C_j$
			\label{alg:fcf_partial_begin}
			\State $N'_j \leftarrow (
			P_{\Sigma_j \rightarrow \Sigma_j \cap \Sigma_k}^{-1}(N_k)
			\cap 
			P_{\Sigma_j \rightarrow \Sigma_j \cap \Sigma_k}^{-1}(C_j) 
			)\cap C_j$ 
			\State $K \leftarrow \overline{F'_j \cap N'_j}$
			\State $F'_j \leftarrow F'_j \backslash K$
			\State $N'_j \leftarrow N'_j \backslash K$
			\label{alg:fcf_partial_end}
			\If{$F'_j \backslash F_j \neq \emptyset \lor 
				 N'_j \backslash N_j \neq \emptyset$}
				\label{alg:fcf_update}
				\State $F_j \leftarrow F_j \cup F'_j$
				\State $N_j \leftarrow N_j \cup N'_j$
				\State $\Sigma_{j,c} \leftarrow
					\{\sigma \in s \}$, where
				\State $s \in
						\left[(\overline{F_j} \backslash F_j) \cup
						(\overline{N_j} \backslash N_j)\right] \backslash	
						(\overline{F_j} \cap \overline{N_j})
						$
				\State \textproc{propagate-fn}$(j, F_j, N_j)$
			\EndIf
		\EndFor
	\EndProcedure
	
	\State $F_i \leftarrow 
		\label{alg:fcf_Fi}
		P_{\Sigma_i \rightarrow \bigcup_{j\neq i}^I \Sigma_i\cap \Sigma_j}(L_{i,f})$
	\State $N_i \leftarrow 
		P_{\Sigma_i \rightarrow \bigcup_{j\neq i}^I \Sigma_i\cap \Sigma_j}(L_{i,nf})$
	\State \textproc{co-languages}($i$, $F_i$, $N_i$)
	\Comment{Beginning of recursion}	
	\ForAll{$j \in I \mid j \neq i$}
		\Comment{Finalization}
		\label{alg:fcf_final}
		\State $L_{j,cf} \leftarrow L_j \cap 
		P_{\Sigma_j \rightarrow \bigcup_{i\neq j}^I \Sigma_i\cap \Sigma_j}^{-1}(F_j)$
		\State $L_{j,cnf} \leftarrow L_j \cap 
		P_{\Sigma_j \rightarrow \bigcup_{i\neq j}^I \Sigma_i\cap \Sigma_j}^{-1}(N_j)$
	\EndFor
	\\
	\Return $\{L_{j,cf}\}$, $\{L_{j,cnf}\}$
\end{algorithmic}
\label{alg:propagate_fn}
\end{algorithm}

Now, we present Algorithm \ref{alg:propagate_fn} which, given a module with the co-faulty
sublanguage defined, computes the co-faulty and co-non-faulty languages for all
the rest modules of the system.
The algorithm starts from a preliminary step at line \ref{alg:fcf_init}.
At this step a projection to the common events $C_j$ is computed for all the
local languages. Projections of co-faulty and co-non-faulty sublanguages and
to the common events, denoted as $F_j, N_j$, are empty. Event sets
$\Sigma_{j,c}$ are sets of the common events, which don't belong neither to
co-faulty and co-non-faulty sublanguages nor to intersection of the sublanguages'
prefix-closures. Since the sublanguages are not defined in the beginning, the
event sets contain all events from the projections. A role of these sets will be
clarified later.
The recursive procedure \emph{propagate-fn} computes $F_j$ and $N_j$ for all the
system's modules, except the module with a fault; the procedure operates with
common events only. Before entering the procedure projections of the faulty
module's sublanguages, $F_i, N_i$ are computed at the step \ref{alg:fcf_Fi}.

The recursive procedure computes all projections $F_j, N_j$ of the adjacent
modules for a given module $k$ (we say that two modules are adjacent to each
other if their languages have events in common). At the first steps
\ref{alg:fcf_partial_begin}-\ref{alg:fcf_partial_end} of the
procedure we compute $F'_j, N'_j$ with respect to the module $k$; these
projections are partial. At the step \ref{alg:fcf_update} we check if some
co-faulty or co-non-faulty strings should be added to the projections computed
earlier. If so, then we update $F_j, N_j$, $\Sigma_{j,c}$ and call the same
procedure to update projections of the adjacent modules. Thus, whenever the
co-faulty or co-non-faulty projections of that module changed,
the projections $F_j, N_j$ are updating with respect to every other module, due
to recursion.
Finally, all the co-faulty and co-non-faulty sublanguages are calculated
for each module at the step \ref{alg:fcf_final}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Construction of the virtual module}


\begin{algorithm} 
\caption{Computing observable information for the faulty module} 
\begin{algorithmic}[1]
	\Require The index  $i \in I$ of the faulty module, 
	$k \in I \mid M(L_{k,cf}) \neq \emptyset \lor M(L_{k,cnf}) \neq
	\emptyset, k \neq i$, the sets $\{L_{j,cf}\}, \{L_{j,cnf}\}, j \in I$.
% 	\State $V \leftarrow \{i\}$ \Comment{Virtual module}

	\ForAll{$j \in I$}
	\label{alg:fco_init}
		\State $D_{j,f} \leftarrow
			P_{\Sigma_j \rightarrow \Sigma_{j,o} \cup 
			\bigcup_{i\neq j}^I \Sigma_i\cap \Sigma_j}(L_{j,f})$
		\State $D_{j,nf} \leftarrow
			P_{\Sigma_j \rightarrow \Sigma_{j,o} \cup 
			\bigcup_{i\neq j}^I \Sigma_i\cap \Sigma_j}(L_{j,nf})$
	\EndFor
	
	\Procedure{propagate-d}{$k$, $D_{k,f}$, $D_{k,nf}$}
		\ForAll{$j \in I \mid j \textrm{ is adjacent to } k$}
			\State $D'_{j,f} \leftarrow 
			P_{\Sigma_j \cup \Sigma_k \rightarrow \Sigma_j \cup \Sigma_o}
			(P_{\Sigma_j \cup \Sigma_k \rightarrow \Sigma_j}^{-1}(F_j) 
			\cap 
			P_{\Sigma_j \cup \Sigma_k \rightarrow \Sigma_k}^{-1}(D_{k,f}))$
			\If{$(D'_{j,f}\backslash D_{j,f} \neq \emptyset) \lor
				(D'_{j,nf}\backslash D_{j,nf} \neq \emptyset)$}
				\State $D_{j,f}\leftarrow D'_{j,f}$
				\State $D_{j,nf}\leftarrow D'_{j,nf}$
				\State \textproc{propagate-d}($j$, $D_{j,f}$, $D_{j,nf}$)
			\EndIf
		\EndFor 
	\EndProcedure
	
	\State \textproc{propagate-d}($k$, $D_{k,f}$, $D_{k,nf}$)
	\label{alg:fco_enter_recursion}
	\State$
	\label{alg:fco_finalize}
	\begin{array}{ll}
	L_{i,f}^{ext} \leftarrow 
	P_{\Sigma_i \rightarrow \Sigma_i \cup \Sigma_o} ( &  
	P_{\Sigma_i \cup \Sigma_o \rightarrow \Sigma_i}^{-1}(L_{i,f}) \cap \\ 
	& 
	P_{\Sigma_i \cup \Sigma_o \rightarrow \Sigma_i}^{-1}(D_{i,f}))
	\end{array}
	$
	\State$
	\begin{array}{ll}
	L_{i,nf}^{ext} \leftarrow 
	P_{\Sigma_i \rightarrow \Sigma_i \cup \Sigma_o} ( &  
	P_{\Sigma_i \cup \Sigma_o \rightarrow \Sigma_i}^{-1}(L_{i,nf}) \cap \\ 
	& 
	P_{\Sigma_i \cup \Sigma_o \rightarrow \Sigma_i}^{-1}(D_{i,nf}))
	\end{array}
	$
	\\
	\Return $L_{i,f}^{ext}, L_{i,nf}^{ext}$
\end{algorithmic}
\label{alg:propagate-d}
\end{algorithm}

The structure of the above algorithm is similar to Algorithm
\ref{alg:propagate_fn}. It starts from computing projections to common and
observable events for the co-faulty and co-non-faulty sublanguages of each
module's language. Then, starting from the module $k$ which has observable
events in its sublanguages, begins a recursive procedure at step
\ref{alg:fco_enter_recursion}. In the procedure we collect only observable
events of other modules which are related to co-faulty or co-non-faulty
sublanguages. Then we propagated these events down to the faulty module.
Finally, at the step \ref{alg:fco_finalize}, the faulty and non-faulty
sublanguages of the faulty module are extended with observable events.

The result of the Algorithm \ref{alg:propagate-d}, the faulty and non-faulty
sublanguages extended with observable events, can be used to verify
diagnosability now. Any approach, which allows us to check for the presence of
indistinguishable strings in the language (the faulty and non-faulty
sublanguages can be united, if necessary), is suitable. We can have the
following outcomes after verification: a) no indistinguishable strings are
broken, b) no indistinguishable strings left, and c) some indistinguishable
strings are broken. In case (a) we pick another module $k \in I$ satisfying
requirements of the Algorithm \ref{alg:propagate-d} for further processing and
verification. In case (b) we may construct a virtual module of the faulty module
$i$ and the module $k$ and declare that the fault is diagnosable with respect to
the virtual module $\{i, k\}$ and stop, or continue and check if exists another
module which can also be used to build a virtual module. In case (c) we should
pick additional module satisfying requirements of the Algorithm
\ref{alg:propagate-d} and continue the process until all the indistinguishable
strings are broken. The following section analyzes what may be considered as a
criteria for choosing the module with observable support $k$.


\subsection{Algorithm to choose a module with observable support}
Assume that the objective function is to have the number of modules in the
system as many as possible, i.e. to have the maximal cardinality of the
partition $J$.
Given an initial set of languages, let rank of $J$ be equal to 0, i.e. $|J| =
|I|$. Let $F$ denotes the subset of languages with faults, and $M$ denotes the
subset of languages with correspondent observable supports.
Assume that it is always possible to make the system modularly diagnosable with
respect to some virtual modules. Then we know that $(\forall f \in F)~\exists m
\in M$. Let $F \cap M = \emptyset$ and $|M| \geq |F|$. Then, to make the system
modularly diagnosable it is required, in the worst case, $|F|$ members of $M$.
Thus, the cardinality of the systems with virtual modules, i.e. the cardinality
of the partition, in the worst case is:
\begin{equation}
	\min |J| = |I| - |F|.
\end{equation}
Let $M \subseteq F$. Then, the cardinality of the partition in the best case
is:
\begin{equation}
	\max |J| = |I| - \left(
		\left\lfloor \frac{|F|}{2} \right\rfloor + \textrm{mod} \frac{|F|}{2}
		\right). 
\end{equation}

As can be seen from the above, in order to maximize the number of modules while
making the virtual modules, we should consider, firstly, the modules which
themselves have faults. We propose a procedure for the given objective function
as follows:

Given the system $S$ of cardinality $|I|$, the subset $F
\subseteq I$ of modules with faults, such that any $f\in F$ is not diagnosable
locally, the subset $M \subseteq I$ of modules with observable supports, such
that $(\forall f \in F)~\{m \in M\}\neq \emptyset$. In order to make the system
diagnosable by minimal number of virtual modules: 
\begin{enumerate}
  \item Initially set the partition $J$ of $I$ such that the rank of $J$ is
  equal to 0;
  \item $(\forall j \in J, f \in j)$ update $j$ as follows: 
  	$j := j \cup \{m \in M \cap F\}$ if $M \cap F \neq \emptyset$,
 $j := j \cup \{m \in M\}$ otherwise, where $\{m\}$ is a singleton of the
 arbitrary chosen observable support for the given $f$, such that the new $j$
 is locally diagnosable; exclude $m$ from $k \in J \mid k \neq j$, and remove
 $k$ from $J$ if $k=\emptyset$.
\end{enumerate} 
The order the observable supports are verified in the procedure guaranties that
we consider, firstly, the languages which themselves contain the faulty
sublanguages, thus maximizing the number of virtual modules in the system.

It worth to note that the above algorithm can be augmented by additional
criteria aimed, for instance, to decrease computational burden.

% The objective function discribes a combinatorial optimisation problem, which can
% be solved by linear programming methods.

% \subsection{Complexity of the Algorithms}
% Algorithm \ref{alg:propagate_fn} makes $n(n-1)/2 \mid n=|I|$ compositions of
% the system's modules in the best case, when each local language is updated only
% once at step \ref{alg:fcf_update}, but the time-complexity in the worst case
% is exponential.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example}
\label{sec:Example}

See the Figures \ref{fig:G1-4} -- \ref{fig:L1_extended}.

\begin{figure}[t]
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
% G1
\node[initial,state] (0)                    {$0$};
\node[above left = 0.5em of 0]{$L_{1}$};
\node[state, accepting]         (1) [above right of=0] {$1$};
\node[state, accepting]         (2) [right of=1]       {$2$};
\node[state, accepting]         (3) [right of=2]       {$3$};
\node[state, accepting]         (4) [right of=3]       {$4$};
\node[state, accepting]         (5) [right of=0] 		{$5$};
\node[]         () [below right of=0] 		{}; %some blank space
\path
(0)	edge [] 		 node {$f$} (1)
(1)	edge [] 		 node {$a$} (2)
(2)	edge [] 		 node {$o_1$} (3)
(3)	edge [] 		 node {$b$} (4)
(4)	edge [loop right] node {$c$} (4)
(0)	edge [] 		 node {$o_1$} (5)
(5)	edge [loop right] node {$c$} (5)
;
\end{tikzpicture}
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
% G2
\node[initial,state, accepting] (0)                    {$0$};
\node[above left = 0.5em of 0]{$L_{2}$};
\node[state, accepting]         (1) [right of=0] 		{$1$};
\node[state, accepting]         (2) [right of=1]       {$2$};
\path
(0)	edge [] 		  node {$a$} (1)
	edge [loop below] node {$c$} (0)
(1)	edge [] 		  node {$d$} (2)
(2)	edge [loop right] node {$c$} (2)
;
% G3
\node[initial,state, accepting] (0') [below of=0]      {$0$};
\node[above left = 0.5em of 0']{$L_{3}$};
\node[state, accepting]         (1') [right of=0']		{$1$};
\node[state, accepting]         (2') [right of=1']     {$2$};
\path
(0')	edge [] 		  node {$b$} (1')
		edge [loop below] node {$c$} (0')
(1')	edge [] 		  node {$e$} (2')
(2')	edge [loop right] node {$c$} (2')
;
% G4
\node[initial,state, accepting] (0'') [below of=0']  {$0$};
\node[above left = 0.5em of 0'']{$L_{4}$}; 
\node[state, accepting]         (1'') [right of=0'']	{$1$};
\node[state, accepting]         (2'') [right of=1'']   {$2$};
\node[state, accepting]         (3'') [right of=2'']   {$3$};
\path
(0'')	edge [] 		  node {$e$} (1'')
		edge [loop below] node {$c$} (0'')
(1'')	edge [] 		  node {$o_2$} (2'')
(2'')	edge [] 		  node {$d$} (3'')
(3'')	edge [loop right] node {$c$} (3'')
;
\end{tikzpicture}
\caption{Automata marking languages $L_1, L_2, L_3$ and $L_4$. $\Sigma_o :=
\{o_1, o_2\}$, $\Sigma_f := \{f\}$}
\label{fig:G1-4}
% \end{figure}

% Fautly and non-faulty
% \begin{figure}[t]
% \centering
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
\node[initial,state] (0)                    {$0$};
\node[above = 3em of 0] {}; %adds some space above
\node[above left = 0.5em of 0]{$L_{1,f}$};
\node[state, accepting, fill=orange]         (1) [right of=0] 		{$1$};
\node[state, accepting, fill=orange]         (2) [right of=1]       {$2$};
\node[state, accepting, fill=orange]         (3) [right of=2]       {$3$};
\node[state, accepting, fill=orange]         (4) [right of=3]       {$4$};

\node[initial,state] (0') [below of=0]                   {$0$};
\node[above left = 0.5em of 0']{$L_{1,nf}$};
\node[state, accepting]         (5)
[right of=0'] 		{$5$};

\path
(0)	edge [] 		 node {$f$} (1)
(1)	edge [] 		 node {$a$} (2)
(2)	edge [] 		 node {$o_1$} (3)
(3)	edge [] 		 node {$b$} (4)
(4)	edge [loop below] node {$c$} (4)
;
\path
(0') edge [] 		 node {$o_1$} (5)
(5)	edge [loop right] node {$c$} (5)
;
\end{tikzpicture}
\caption{Automata marking the faulty and non-faulty sublanguages of $L_1$}
\label{fig:G1_faulty}
% \end{figure}

% Projection to common events (G1)
% \begin{figure}[t!]
% \centering
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
\node[initial,state] (0)                    {$0$};
\node[above = 3em of 0] {}; %adds some space above
\node[above left = 0.5em of 0]{$F_1$};
\node[state, accepting, fill=orange]         (2) [right of=0]       {$2$};
\node[state, accepting, fill=orange]         (4) [right of=2]       {$4$};

\node[initial,state] (0') [] at (5,0)              {$0$};
\node[above left = 0.5em of 0']{$N_1$};
\node[state, accepting]         (5) [right of=0'] 		{$5$};

\path
(0)	edge [] 		 node {$a$} (2)
(2)	edge [] 		 node {$b$} (4)
(4)	edge [loop right] node {$c$} (4)
;
\path
(0') edge [] 		 node {$c$} (5)
(5)	edge [loop right] node {$c$} (5)
;
\end{tikzpicture}
\\

\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
% F2
\node[initial,state] (0)                    {$0$};
\node[above left = 0.5em of 0]{$F_2$};
\node[state, accepting, fill=orange]         (1) [right of=0] 		{$1$};
\node[state, accepting, fill=orange]         (2) [right of=1]       {$2$};
\path
(0)	edge [] 		  node {$a$} (1)
(1)	edge [] 		  node {$d$} (2)
(2)	edge [loop right] node {$c$} (2)
;
% F2
\node[initial,state, accepting] (0') at (5,0) {$0$};
\node[above left = 0.5em of 0']{$N_2$};
\path
(0') edge [loop below] node {$c$} (0')
;
\end{tikzpicture}
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
% F4
\node[initial,state] (0)                    {$0$};
\node[above left = 0.5em of 0]{$F_4$};
\node[state ]         (1) [right of=0] 		{$1$};
\node[state, accepting, fill=orange]         (2) [right of=1]       {$2$};
\path
(0)	edge [] 		  node {$e$} (1)
(1)	edge [] 		  node {$d$} (2)
(2)	edge [loop right] node {$c$} (2)
;
\node[initial,state, accepting] (0') at (5,0) {$0$};
\node[above left = 0.5em of 0']{$N_4$};
\path
(0') edge [loop below] node {$c$} (0')
;
\end{tikzpicture}
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7}, 
	every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
% F3
\node[initial,state] (0)                    {$0$};
\node[above left = 0.5em of 0]{$F_3$};
\node[state, accepting, fill=orange]         (1) [right of=0] 		{$1$};
\node[state, accepting, fill=orange]         (2) [right of=1]       {$2$};
\path
(0)	edge [] 		  node {$b$} (1)
(1)	edge [] 		  node {$e$} (2)
(2)	edge [loop right] node {$c$} (2)
;
\node[initial,state, accepting] (0') at (5,0) {$0$};
\node[above left = 0.5em of 0']{$N_3$};
\path
(0') edge [loop below] node {$c$} (0')
;
\end{tikzpicture}
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
% F4
\node[initial,state] (0)                    {$0$};
\node[above left = 0.5em of 0]{$F_4$};
\node[state, accepting, fill=orange]         (1) [right of=0] 		{$1$};
\node[state, accepting, fill=orange]         (2) [right of=1]       {$2$};
\path
(0)	edge [] 		  node {$e$} (1)
(1)	edge [] 		  node {$d$} (2)
(2)	edge [loop right] node {$c$} (2)
;
\node[initial,state, accepting] (0') at (5,0) {$0$};
\node[above left = 0.5em of 0']{$N_4$};
\path
(0') edge [loop below] node {$c$} (0')
;
\end{tikzpicture}

\caption{Automata marking sublanguages $F_1$ and $N_1$ of the faulty module,
and co-faulty and co-non-faulty languages of the modules 2, 3 and 4 in the
order they are composed (top-down): 1-2, 2-4, 1-3, 3-4. Note, that the
sublanguage $F_4$ is defined partially at first, then fully}
\label{fig:FN}
\end{figure}

% Fautly and non-faulty
\begin{figure}[t]
% \centering
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
\node[initial,state] (0) {$0$};
\node[above = 0.5em of 0]{$L_{4,cf}$}; 
\node[state, accepting, fill=orange]         (1) [right of=0]	{$1$};
\node[state, accepting, fill=orange]         (2) [right of=1]   {$2$};
\node[state, accepting, fill=orange]         (3) [right of=2]   {$3$};
\path
(0)	edge [] 		  node {$e$} (1)
(1)	edge [] 		  node {$o_2$} (2)
(2)	edge [] 		  node {$d$} (3)
(3)	edge [loop right] node {$c$} (3)
;
\node[initial,state, accepting] (0') [below of=0] {$0$};
\node[above left = 0.5em of 0']{$L_{4,cnf}$};
\path
(0') edge [loop below] node {$c$} (0')
;
\end{tikzpicture}
\caption{Automata marking co-faulty and co-non-faulty sublanguages of
the language $L_4$. Automata for the sublanguages of the modules 2 and 3 are
equal to the ones depicted in the Figure \ref{fig:FN}}
\label{fig:L4_f}
% \end{figure}

% Projections to common and observable events
% \begin{figure}[t]
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7}, 
	every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
% F3
\node[initial,state] (0)                    {$0$};
\node[above = 3em of 0] {}; %adds some space above
\node[above left = 0.5em of 0]{$D_{3,f}$};
\node[state, accepting, fill=orange]         (1) [right of=0] 		{$1$};
\node[state, accepting, fill=orange]         (2) [right of=1]       {$2$};
\node[state, accepting, fill=orange]         (2') [right of=2]       {$2'$};
\path
(0)	edge [] 		  node {$b$} (1)
(1)	edge [] 		  node {$e$} (2)
(2)	edge [] 		  node {$o_2$} (2')
(2')	edge [loop right] node {$c$} (2')
;
\end{tikzpicture}
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
\node[initial,state] (0)                    {$0$};
\node[above left = 0.5em of 0]{$D_{2,f}$};
\node[state, accepting, fill=orange]         (1) [right of=0] 		{$1$};
\node[state, accepting, fill=orange]         (1') [right of=1] 		{$1'$};
\node[state, accepting, fill=orange]         (2) [right of=1']       {$2$};
\path
(0)	edge [] 		  node {$a$} (1)
(1)	edge [] 		  node {$o_2$} (1')
(1')edge [] 		  node {$d$} (2)
(2)	edge [loop right] node {$c$} (2)
;
\end{tikzpicture}
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
\node[initial,state] (0)                    {$0$};
\node[above left = 0.5em of 0]{$D_{1,f}$};
\node[state, accepting, fill=orange]         (2) [right of=0]       {$2$};
\node[state, accepting, fill=orange]         (2') [below of=2]      
{$2'$}; \node[state, accepting, fill=orange]         (4) [right of=2]      {$4$};
\node[state, accepting, fill=orange]         (4')[below of=4]{$4'$};
\path
(0)	edge [] 		 node {$a$} (2)
(2)	edge [] 		 node {$b$} (4)
	edge [] 		node {$o_2$} (2')
(2')edge [] 		 node {$b$} (4')
(4)	edge [loop right] node {$c$} (4)
	edge [] 		node {$o_2$} (4')
(4')edge [loop right] node {$c$} (4')
;
\end{tikzpicture}
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
\node[initial,state] (0)                    {$0$};
\node[above left = 0.5em of 0]{$D_{1,f}$};
\node[state, accepting, fill=orange]         (2) [right of=0]       {$2$};
\node[state, accepting, fill=orange]         (4) [right of=2]       {$4$};
\node[state, accepting, fill=orange]         (4')[right of=4] {$4'$};
\path
(0)	edge [] 		 node {$a$} (2)
(2)	edge [] 		 node {$b$} (4)
(4) edge [] 		node {$o_2$} (4')
(4')edge [loop right] node {$c$} (4')
;
\end{tikzpicture}
\caption{Automata marking $D_{j,f}$ of the modules 1, 2 and 3 in
the order they are composed (top-down): 4-3, 4-2, 2-1, 3-1. Automata marking
$D_{j,nf}$ are not depicted since they have no observable events}
\label{fig:D}
% \end{figure}


% Fautly and non-faulty
% \begin{figure}[t!]
% \centering
\begin{tikzpicture}[->,>=stealth, node distance=2cm, auto, shorten >=1pt,
semithick, initial text=,	
	every node/.style={scale=0.7},
    every state/.style={fill=green!40,text=black},
    accepting/.style={double distance=1.5pt, outer sep=0.75pt+\pgflinewidth}
    ]
% \draw[help lines] (0,-2) grid (6,2);
\node[initial,state] (0)                    {$0$};
\node[above = 3em of 0] {}; %adds some space above
\node[above left = 0.5em of 0]{$L_{1,f}$};
\node[state, accepting, fill=orange]         (1) [right of=0] 		{$1$};
\node[state, accepting, fill=orange]         (2) [right of=1]       {$2$};
\node[state, accepting, fill=orange]         (3) [right of=2]       {$3$};
\node[state, accepting, fill=orange]         (4) [right of=3]       {$4$};
\node[state, accepting, fill=orange]         (4')[right of=4]       {$4'$};

\node[initial,state] (0') [below of=0]                   {$0$};
\node[above left = 0.5em of 0']{$L_{1,nf}$};
\node[state, accepting]         (5)
[right of=0'] 		{$5$};

\path
(0)	edge [] 		 node {$f$} (1)
(1)	edge [] 		 node {$a$} (2)
(2)	edge [] 		 node {$o_1$} (3)
(3)	edge [] 		 node {$b$} (4)
(4) edge [] 		 node {$o_2$} (4')
(4')edge [loop below] node {$c$} (4')

;
\path
(0') edge [] 		 node {$o_1$} (5)
(5)	edge [loop right] node {$c$} (5)
;
\end{tikzpicture}
\caption{Automata marking the faulty and non-faulty sublanguages of $L_1$ after
the backward Algorithm. The observation of $L_{1,f}$ is $\{o_1o_2\}$ differs
from the observation of $L_{1,nf}$ which is $\{o_1\}$}
\label{fig:L1_extended}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}
\label{sec:Conclusions}


\bibliographystyle{IEEEtran}
\bibliography{References}


\end{document}