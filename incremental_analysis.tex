% \documentclass[a4paper,oneside]{article}
\documentclass[a4paper, 10pt, conference]{ieeeconf}
\IEEEoverridecommandlockouts
 % This command is only
  % needed if you want
  % to use the \thanks
  % command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\usepackage[pdftex, pdftitle={DiagnosabilityVerification of Discrete-Event
Systems}, pdfauthor={Dmitry Myadzelets}, bookmarks=false,
% colorlinks=true, linkcolor=black
]{hyperref}

\usepackage{amsfonts, amssymb, amsmath} 
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{arrows,positioning,automata,shadows,fit,shapes}

\begin{document}

\title{How to Make a Discrete-Event System \\ Modularly Diagnosable.
Algorithm} 
\author{
% 	Dmitry Myadzelets$^{*,1,2}$
% 	, Andrea Paoli$^{1,3}$
	\\ \today
	\thanks{$^{1}$Center for Research on Complex Automated Systems (CASY), DEI,
	University of Bologna, Viale Pepoli 3/2, 40123, Bologna, Italy}
		\thanks{$^{2}$E-mail: {dmitry.myadzelets@gmail.com}}
		\thanks{$^{3}$E-mail: {andrea.paoli@unibo.it}}
}
\maketitle

% To meet requirements of EU funding
% http://eacea.ec.europa.eu/about/eacea_logos_en.php "This project has been
% funded with support from the European Commission. This publication reflects
% the views only of the author, and the Commission cannot be held responsible
% for any use which may be made of the information contained therein."
% \begin{figure}[!b]
% \begin{tabular}{l p{60mm}}
%  	\includegraphics[height=10mm]{EU_flag.eps}
%  	& \vspace{-10mm} \footnotesize
%  	$^{*}$With the support of the Erasmus Mundus Action 2 programme of the
%  	European Union.
% \end{tabular}
% \end{figure}

\begin{abstract}

\end{abstract}

\begin{keywords}
Discrete Event Systems, Modular Structure, Distributed Diagnosability
\end{keywords}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}
\label{sec:Preliminaries}
Let $I := \{1,2,\ldots,n\} \subset  \mathbb{N}$ be an index set. A system is
defined as a set of automata $\{G_{i \in I}\}$ and a correspondent set
of languages $\{L_{i \in I}\}$. We use the term \emph{local} in context
of the members of the sets, and \emph{global} for the entire set.
For the simplicity of notation we restrict the natural projection, commonly
defined over Kleene closure on event sets, to the system's languages as
follows: $P_i(L) := \{s\mid s\in L_{i}\}$ and $P_i^{-1}(L_{i}) := u \mid u
\in L\}, ~i \in I$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{General form of the approach}
\label{sec:General}
In the first article we introduced an analysis of a trivial system of two
languages, with conditions for the both languages, when one language makes the
system diagnosable if the other language is not locally diagnosable.
The conditions are sufficient, and they also are necessary if we assume that the
local languages are not affected by concurrency, i.e. $L_i = P_i(L)$. Some of
the conditions require one language to have common events with the other one. In
general, a system consists of many modules, and a language which is not
diagnosable locally may have no common events with a language which can
potentially change diagnosability, but have common events with other languages.
In this case one can compose the all other languages with the faulty language,
reducing the system to the form of the trivial case. A formal description of
such approach is given below.

The setup for the problem is following. Let a system be defined as a set of
local languages $S := \{L_{i\in I}\}$, and let faulty behaviours be defined for
any $i \in I$, i.e. each language $L_i$ can be disjoint into faulty and
non-faulty sublanguages: $L_{i,f}$ and $L_{i,nf}$. We assume that $(\forall i
\in I) L_i = P_i(L)$, i.e. each local language is globally consistent in terms
of \cite{su_global_2005}.

First, we recall the definition of diagnosability of virtual modules. Let $J$ be
a partition of $I$. Given the system $S$, $J$ and set of observable
projections $\{M_j := \Sigma_j^* \rightarrow \Sigma_{j,o}^* \mid j \in J \}$
where $\Sigma_j := \bigcup_i \Sigma_i,~ 
	\Sigma_{j,o} := \bigcup_i \Sigma_{i,o} \mid 
	i\in j$. 
The system is modularly diagnosable with respect to $J$ and $\{M_j\}$ 
if the following holds true:
\begin{equation}
	\begin{array}{l}
		\forall(i \in I, s \in L_{i,f}, t \in L_{i,f}/s)
		\\
		(\exists n \in \mathbb{N})
		(|t| \geq n)
		\\
		\left[ M_j(P_i^{-1}(st)) \cap M_j(P_i^{-1}(L_{i,nf})) = \emptyset \right].
	\end{array}
\end{equation}
The definition requires each fault originated in any language of the subset $j$
to be diagnosed observing only events of the languages from the same subset $j$.
However, the languages $L_j$ were not given, and do not have to be necessary
constructed. That is why we use the term \emph{virtual module} as a synonym for
the subset $j$.

Second, we recall Lemma 2 of the first article, and rewrite it for an arbitrary
couple of languages as follows.

\begin{lemma}
Given a tuple $\left< L_i, L_j, s, u\right> \mid i, j \in \mathbb{N}, i\neq j$,
where $L_i, L_j$ are languages, and $s, u \in L_i$. The strings $s, u$ are
distinguished in the language $L_i \parallel L_j$, if for the string $s$ exists
an adjacent observable support $K_j \subseteq L_j$ which satisfies the
condition:
\end{lemma} 
\begin{equation}
\label{con:distinquished}
	\begin{array}{l}
	 	(\forall t \in K_j)
	 	(\exists \sigma \in t \mid \sigma \in \Sigma_i \cap \Sigma_j)
	 	(\sigma \not \in u)
	 	\\
	 	(\forall w\sigma \in \overline{t})
	 	[M_j(t\backslash w\sigma) \neq \emptyset].
	\end{array}
\end{equation}
% where $M'_j: (\Sigma_i \cup \Sigma_j)^* \rightarrow (\Sigma_{j,o}\backslash
% \Sigma_i)^*$.
Informally, the lemma imposes a requirement for the string $s$ to have an
observable support in another language, which garanties that we can observe some
events in that language before any continuation of the string $s$.
Then, the lemma defines a condition which allows us to distinguish these
observations from an observation of the string $u$.

Now, we rewrite Lemma 3 from the first article in the context of our setup, as
follows:
\begin{lemma}
Given a set of languages $j \in J$, the virtual module $j$ is diagnosable with
respect to $M_j$ if:
\end{lemma}
\begin{equation}
	\begin{array}{l}
% 		(\forall i \in j, s \in L_{i,f}, t \in L_i \backslash \overline{L_{i,f}})
		(\forall i \in j, 
			s \in P_i^{-1}(L_{i,f}), 
			t \in P_i^{-1}(L_{i,nf}))
% 			t \in P_i^{-1}(L_i) \backslash \overline{P_i^{-1}(L_{i,f})})
		\\
		(\exists k \in j \mid k \neq i) \textrm{ and }
		\\
		\textrm{condition (\ref{con:distinquished}) holds for at least one of
		the tuples:}
		\\
		\left<P_i^{-1}(L_i), L_k, s, t \right>,
		\left<P_i^{-1}(L_i), L_k, t, s \right>.
	\end{array}
\end{equation}
The lemma implies that the virtual module is diagnosable if we can distinguish
all faulty strings from all non-faulty strings. 
% excluding all prefixies of the faulty strings
% Note, that exclusion of the prefixes comes from fact that the non-compositional
% analysis is used.
From the lemma it can be seen that for one faulty sublanguage there can be a
subset of languages with observable supports, satisfying the conditions. In
order to make the system modularly diagnosable, thus, one needs to find a
relevant partition, with a desired ditribution of modules. It worth to note,
that the partitioning implies that languages with faults are in subsets with the
languages which have observable events. Thus, other languages which have no
faults and have no observable events, as well the languages with observations
which have no effect for the diagnosability property, will be in other subsets.
Since it is enough to pick just one module satisfiying the conditions, we
propose a procedure for this task, in the next section.

\section{Algorithm to choose a module with observable support}
Assume that the objective function is to have the number of modules as many as
possible, i.e. to have the maximal cardinality of the partitition $J$.
Given an initial set of languages, let rank of $J$ be eqal to 0, i.e. $|J| =
|I|$. Let $F$ denotes the subuset of languages with faults, and $M$ denotes the
subset of languages with correspondent observable supports.
Assume that it is alwasy possible to make the system modularly diagnosbile with
respect to some virtual modules. Then we know that $(\forall f \in F)~\exists m
\in M$. Let $F \cap M = \emptyset$ and $|M| \geq |F|$. Then, to make the system
modularly diagnosable it is required, in the worst case, $|F|$ members of $M$.
Thus, the cardinality of the systems with virtual modules, i.e. the cardinality
of the partition, in the worst case is:
\begin{equation}
	\min |J| = |I| - |F|.
\end{equation}
Let $M \subseteq F$. Then, the cardinality of the partition in the best case
is:
\begin{equation}
	\max |J| = |I| - \left(
		\left\lfloor \frac{|F|}{2} \right\rfloor + \textrm{mod} \frac{|F|}{2}
		\right). 
\end{equation}

As can be seen from the above, in order to maximize the number of modules while
making the virtual modules, we should consider, firstly, the modules which
themselves have faults. We propose a procedure for the given objective function
as follows:

Given the system $S$ of cardinality $|I|$, the subset $F
\subseteq I$ of modules with faults, such that any $f\in F$ is not diagnosable
locally, the subset $M \subseteq I$ of modules with observable supports, such
that $(\forall f \in F)~\{m \in M\}\neq \emptyset$. In order to make the system
diagnosable by minimal number of virtual modules:
\begin{enumerate}
  \item Initially set the partition $J$ of $I$ such that the rank of $J$ is
  equal to 0;
  \item $(\forall j \in J, f \in j)$ update $j$ as follows: 
  	$j := j \cup \{m \in M \cap F\}$ if $M \cap F \neq \emptyset$,
 $j := j \cup \{m \in M\}$ otherwise, where $\{m\}$ is a singleton of the
 arbitrary choosen observable support for the given $f$, such that the new $j$
 is locally diagnosable; exclude $m$ from $k \in J \mid k \neq j$, and remove
 $k$ from $J$ if $k=\emptyset$.
\end{enumerate} 
The order the observable supports are verified in the procedure garanties that
we consider, firstly, the languages which themselves contain the faulty
sublanguages, thus maximizing the number of virtual modules in the system.

It worth to note that the above algorithm can be augumented by additional
criterias, for instance, as a way to decrease computational expences.

% The objective function discribes a combinatorial optimisation problem, which can
% be solved by linear programming methods.

\section{\ldots}

\begin{definition}
\label{def:graph}
Given $\{L_i \mid i \in I \}$, let $\mathcal{G} = (I, E)$ be an undirected
graph where $E \subseteq I \times I$ such that
$$(\forall i, j \in I)(i, j) \in E \Leftrightarrow 
	\Sigma_i \cap \Sigma_j \neq \emptyset \mid i \neq j.$$
\end{definition}
% Recall that in graph theory a simple path is a path in a graph which does not
% have repeating vertices.


 \begin{definition}
\label{def:co-faulty}
Given $i, j \in I$, $L_{i,f} \subseteq L_i$,
we say that a sublanguage $L_{j,cf} \subseteq L_j$ is \emph{co-faulty} with
respect to $L_{i,f}$ if 
$$\forall s \in L_{j,cf}, P_j^{-1}(s) \subseteq 
	P_i^{-1}(L_{i,f}) \backslash P_i^{-1}(L_{i,nf}).$$
\end{definition}


\begin{lemma}
\label{lem:co-faulty-if-path}
Given $L_{i,f} \mid i \in I$ and set $\{L_{j,cf} \subseteq L_j \mid j \in J
\subseteq I, j \neq i\}$ where $L_{j,cf}$ is co-faulty with respect to $L_{i,f}$. 
For any $j \in J$ the $L_{j,cf}$ is not empty only if exists a path between $i$
and $j$ in the graph.
\end{lemma}

\begin{proof}(Sketch) 
Let $I = \{i, j\}$ and a faulty non empty sublanguage
$L_{i,f} \subseteq L_i$. Assume that $L_{j,cf} \subseteq L_j$ is not
empty, and there is no path between $i$ and $j$ in the graph, i.e.
$\Sigma_i \cap \Sigma_j = \emptyset$. \ldots by properties of intersection of
inverse projections (parallel composition).
\end{proof}

[May exist more then one paths between two vertices]  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Review of existing approaches}

The work \cite{su_global_2005} presents an algorithm named \emph{Computational
Procedure for Global Consistency (CPGS)} to find the \emph{supremal
global support}. Given a system 
$\{ L_i \mid i \in I \subset \mathbb{N} \}$ 
and its projections $\{ M_i \}$, the supremal global support is
\begin{equation}
	Sup\Gamma = \{ P_i(\parallel M_i^{-1}M_i(L_i))\}.
\end{equation}
Informally, a string of a local language is in the global support if the string
satisfies the conditions:
\begin{enumerate}
  \item the string contains observable events;
  \item the string is not blocked in the global language. 
\end{enumerate}
Supremum implies that the all strings satisfying the above conditions have
beed found.

In words, the CPGS algorithm consequently computes the projection to the common
events and then the parallel composition of this projection with a next module.
Thus, the last language in the sequence is equal to $P_i(L)$. The above
procedure is repeated with each module placed as the final in the sequence.

The order the modules are placed in the sequence for the algorithm may be
random. Since here only common events cause growth of the composed language,
intuitevely, the ordering should be done with respect to them. Indeed, the
article presents a heuristic ordering procedure for that, and introduces some
parameters described below.

The first parameter represents the space complexity of parallel composition of
two languages as follows:
\begin{equation}
	A_{i,j} = \frac{| X_i \parallel X_j |}{|X_i|\times |X_j|}.
\end{equation}
It is the ratio of the minimal state space cardnality of the actual parallel
composition result to the state space cardinality of the composition in the
worst case.

The second parameter represents the space complexity of natural projection with
respect to the events common for two languages:
\begin{equation}
	B_{i,j} = \frac{
		| P_{\Sigma_i \cup \Sigma_j \rightarrow \Sigma_i \cap \Sigma_j}
		(X_i \parallel X_j) |}
		{| X_i \parallel X_j |}.
\end{equation}
It is the ratio of the minimal state space cardinality of the projection to the
state space cardinality of the original language.

The lower the parameter $A$ the higher the coupling of two modules, i.e. more
common events the modules have, and less memory is required for the computation
of the parallel composition. Hence, we are interested to minimize $A$. The lower
parameter $B$ implies less memory for the result of the projection. However,
trying to minimize $B$ can lead to the increasing of $A$. Thus, the authors
minimize both $A$ and $B$. Since at each step of the algorithm only one module is
selected, the parameters can not be minimized independently. Therefore, the
product of $A$ and $B$ was choosen to be minimized:
\begin{equation}
	C = A \times B = 
		\frac{| P_{\Sigma_i \cup \Sigma_j \rightarrow \Sigma_i \cap \Sigma_j}
		(X_i \parallel X_j) |}
		{|X_i|\times |X_j|}.
\end{equation}

In computer science the algorithm the authors use is called \emph{gready
algorithm}. Here it starts with a random module, and makes a local optimal
choice based on the value of parameters $C$ calculated for the candidate set.
The candidate set includes all the neighbor modules except the goal module. If
the set of neighbors is empty then it includes all unprocessed modules except
the goal module. The algorithm finishes after no any but the goal module can be
included to the candidate set.

The time complexity of the algorithm is $O(n^2)$. It requires $|X|^n$ state
space in the worst case, when a goal module splits the coupling graph into
separate parts (star shape). 
% However, the space complexity can be impoved up to $n|X|$ if the splitted parts
% are processed separately first, and then the goal module is processed with all
% of them. << Too BIG complexity difference. Check it twice!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algorithm}
\label{sec:Algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\label{sec:Conclusion}


\bibliographystyle{IEEEtran}
\bibliography{References}


\end{document}